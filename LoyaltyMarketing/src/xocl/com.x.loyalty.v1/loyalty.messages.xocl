package com.x.loyalty.v1{
	import com.x.core.v1.*
	
	record Points {
		string type; //i.e. "X_Airline_FrequentFlyerMiles" or "BankOfX_Reward"
		long value;
	}
	
	record Balance {
		string type; //i.e. "X_Airline_FrequentFlyerMiles" or "BankOfX_Reward"
		long available;
		long pending_earn;
		long pending_spend;
		long spent;
	}
	
	record LoyaltyCustomer {    //how much customer information do we need?  was ocl.Contact
		union{guid, EntityId} customerId;
		array<Balance>? balance;
		array<Reward>? rewards;
	}

	record LoyaltyCustomerError {
		array<Error> errors;
	}

	record LoyaltyCustomerAvailableBalance{
		union{guid, EntityId} customerId;
		string type; //i.e. "X_Airline_FrequentFlyerMiles" or "BankOfX_Reward"
		long available;
	}


	record LoyaltyCustomerIdError {
		string customerId;
		array<Error> errors;
	}

	enum LoyaltyReportType {
		LOYALTY_CAMPAIGN_PERFORMANCE
	}

	enum EventType {
		ORDER_PLACED,
		REFERRAL,
		SOCIAL_NETWORK
	}

	record Event {
		union{EventType,string} type;
		datetime time;
	}
	
	
	/**
	 * A reward is generated by the Loyalty Provider whenever the customer has
	 * generated the appropriate events that satisfy the earning rules 
	 * of any active campaign.
	 */
	record Reward {
		string id;
		RewardData rewardData;
	}
	
	record RewardData{
		array<Event> events;
		
		Points earnedPoints;
		
		datetime createdTime;
		datetime lastUpdatedTime;
		
	    string? channelId;
	}
	

	record RewardError {
		Reward reward;
		array<Error> errors;
	}
	
	
	record CreateReward {
		union{guid, EntityId} customerId;
	 	RewardData reward;
	}
	
	record CreateRewardSucceeded {
		union{guid, EntityId} customerId;
		Reward reward;
	}
	
	record CreateRewardFailed {
		union{guid, EntityId} customerId;
		RewardData reward;
		array<Error> errors;
	}

	
	record LookupCustomerRewardData {
		union{guid, EntityId} customerId;
	}
		
	record LookupCustomerRewardDataSucceeded {
		LoyaltyCustomer customer;
	}
	
	record LookupCustomerRewardDataFailed {
		union{guid, EntityId} customerId;
		array<Error> errors;
	}
	
	record PredictOrderReward{
	    union{guid, EntityId} customerId;
		
		/** The total paid by the customer (total of items, fees, taxes, etc.) */ 
		CurrencyAmount grandTotal;
	
		/** Total of all the items -- without taxes, fees, etc. */
		CurrencyAmount itemPriceTotal;
		
		array<RewardPredictionOrderLine> orderLine;	
	}
	
	record RewardPredictionOrderLine{
		string productSku;
		int quantity;		
	}
	
	record PredictOrderRewardSucceeded{
		PredictOrderReward request;
		array<Points> predictedPoints;
	}
	
	record PredictOrderRewardFailed{
		PredictOrderReward request;
		array<Error> errors;
	}
	
	record SpendPoints{
		 union{guid, EntityId} customerId;
		 Balance originalBalance;  //this is for optimistic update.  We can detect if the balance is updated.
		 long pointToSpend;
	}
	record SpendPointsSucceeded{
	     union{guid, EntityId} customerId;
		 Balance newBalance;
	}
	record SpendPointsFailed{
		 SpendPoints request;
		 array<Error> errors;
	}
	
	record GetLoyaltyReport{
		long numberOfDays;
		datetime? endDate;
	}
	
	record GetLoyaltyReportSucceeded{
		GetLoyaltyReport request;
		LoyaltyReport report;
	}
	
	record GetLoyaltyReportFailed{
		GetLoyaltyReport request;
		array<Error> errors;
	}
	
	record LoyaltyReport{
		long numberOfDays	"unit time (in days)"
		double averageTransactionFrequency  "Average # of customer purchases / unit time"
		double retentionRate "% of customers who return to purchase / unit time" 
		double averageTransactionValue "Average shopping cart value"
		double customerPointUseEngagement "% of customers who redeem or use points"
		double rewardedActionsPerCustomer "Number of rewarded actions / customer" 
	}
}